/*
Copyright (c) 2010-2012 Thomas Schaffter & Ricard Delgado-Gonzalo

We release this software open source under a Creative Commons Attribution
-NonCommercial 3.0 Unported License. Please cite the papers listed on
http://lis.epfl.ch/wingj when using WingJ in your publication.

For commercial use, please contact Thomas Schaffter
(thomas.schaff...@gmail.com).

A brief description of the license is available at
http://creativecommons.org/licenses/by-nc/3.0/ and the full license at
http://creativecommons.org/licenses/by-nc/3.0/legalcode.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/**
 * Implements methods for visualizing a virtual biological system generated using WingJ.
 *
 * The implementation allows the following application: the user can select
 * between the wild type and Pent2-5 mutant phenotype of the Drosophila wing
 * (pouch). The age of the wing can also be selected (80 hours after egg laying,
 * 90 hours, etc.). Finally, the expression of up to three gene products can
 * be displayed at the same time using the RGB channels of the image. These
 * variables (genotype, three genes and the age) are used to build the image
 * to display.
 *
 * First, the image filenames are built and stored from the combination of
 * the different values for each variable. The images are then loaded in
 * parallel. There are also two types of images: preview (displayed online)
 * and HD (larger images displayed when clicking on the preview). During the
 * loading of the preview images, a message is displayed in place of the
 * image preview. When the preview images are loaded, the message is removed
 * and the selected image preview is shown. HD images are only computed when
 * required, i.e. when the user click on the image preview.
 *
 * Canvas are used to manipulate RGBA images. The final output is return as
 * an image object so that the user can save it to file using right-click >
 * Save link as... For each gene, an image is loaded and is drawn on one of
 * the RGB channel. In addition, masks can be provided. Here a mask is selected
 * depending on the selected genotype and age, which both affect the shape
 * of the virtual model. Pixels from the mask are only applied if they are
 * full opaque (i.e. mask[i+3] == 255, i+3 is used for the fourth channel, A).
 * Otherwise pixel values from the RGB channels are used. The mask can be used
 * to provide additional information such as the scale of the image.
 *
 * The images released with this implementation have been generated using
 * WingJ. First, each wing got his structure model and saved to file. Then
 * "Aggregated expression datasets" have been generated to produce the RGB
 * images shown here (code for editing the images is available in the package
 * "batch"). Here we batch edited the images so that they fully exploit the
 * display range 0 to 255 (0 is black, 255 is white) and have the same canvas
 * size (determined by the largest image canvas). Finally, the images are
 * resized first to generate the HD images (here 800 x 626), then to produce
 * the preview images (here 350 x 273). The masks are binary images also
 * generated by WingJ. Only those were edited in a third-party software to
 * combine the information from the mask with the mean+std contour of the
 * structure model. Finally, the white pixels of the original binary masks
 * have been removed (made transparent) before saving the image back to
 * PNG format.
 *
 * @version December 11, 2012
 *
 * @author Thomas Schaffter (thomas.schaff...@gmail.com)
 */

/** Canvas on which the images are painted. */
var canvas;
/** Context obtained from the canvas to paint. */
var context;
/** Width of the canvas. */
var canvasWidth = 350;
/** Height of the canvas. */
var canvasHeight = 273;

/** Canvas on which the images are painted. */
var canvasHD;
/** Context obtained from the canvas to paint. */
var contextHD;
/** Width of the canvas for lightbox image (original size). */
var canvasHDWidth = 800;
/** Height of the canvas for lightbox image (original size). */
var canvasHDHeight = 626;

/** List of genotypes. */
var genotypes = ["wt", "pent2-5"];
/** List of genotypes for formatted texts (e.g. used for the caption). */
var genotypesFormatted = ["Wild type", "Pent2-5 mutant"];
/** List of genes. */
var genes = ["brkAB", "dadGFP", "ombAB", "pmadAB", "salAB", "none"];
/** List of genes for formatted texts (e.g. used for the caption). */
var genesFormatted = ["Brk-AB", "Dad-GFP", "Omb-AB", "Pmad-AB", "Sal-AB", "none"];
/** List of ages. */
var ages = ["80H", "90H", "100H", "110H"];
/** List of ages for formatted texts (e.g. used for the caption). */
var agesFormatted = ["80 hours", "90 hours", "100 hours", "110 hours"];

/**
 * Relative path to the images folder (from the page calling these method).
 * This variable can be redefined in the header of the calling HTML page.
 */
var imagesDirectory = "images/"

/** List of all image filenames. */
var imagesFilenames = new Array();
/** List of images. */
var images = new Array();

/** List of all mask image filename. */
var masksFilenames = new Array();
/** List of masks. */
var masks = new Array();

/** List of all HD image filenames. */
var imagesHDFilenames = new Array();
/** List of HD images. */
var imagesHD = new Array();

/** List of all HD mask image filename. */
var masksHDFilenames = new Array();
/** List of HD masks. */
var masksHD = new Array();

/** Debug mode. */
var debug = true;

// ============================================================================
// METHODS

/** Executed when the window including this file is loaded. */
window.onload = function() {

	// gets canvas
    // canvas = document.getElementById('panel');
	canvas = document.createElement("canvas");
	canvas.width = canvasWidth;
	canvas.height = canvasHeight;
    context = canvas.getContext('2d');

	canvasHD = document.createElement("canvas");
	canvasHD.width = canvasHDWidth;
	canvasHD.height = canvasHDHeight;
    contextHD = canvasHD.getContext('2d');

	// paints background
    context.fillStyle = '#ffffff';
    context.fillRect(0, 0, canvasWidth, canvasHeight);
	// canvas.style.border = "1px solid";  // Put a border around the canvas.
	contextHD.fillStyle = '#ffffff';
    contextHD.fillRect(0, 0, canvasHDWidth, canvasHDHeight);

	// builds image filenames
	var index = 0;
	var maskIndex = 0;
	var img = null;
	for (var i = 0; i < genotypes.length; i++) {
		for (var j = 0; j < genes.length; j++) {
			for (var k = 0; k < ages.length; k++) {
				imagesFilenames[index] = imagesDirectory + "preview/" + genotypes[i] + "_" + genes[j] + "_" + ages[k] + ".png"; // "images/myimage.jpg";
				imagesHDFilenames[index] = imagesDirectory + "HD/" + genotypes[i] + "_" + genes[j] + "_" + ages[k] + ".png";
				if (genes[j] == "none") {
					imagesFilenames[index] = "404";
					imagesHDFilenames[index] = "404";
				}

				// masks are functions of the genotype and age
				// here we only take the mask of "pmadAB"
				if (j == 0) {
					masksFilenames[maskIndex] = imagesDirectory + "preview/masks/" + genotypes[i] + "_" + ages[k] + "_mask.png";//"images/preview/masks/" + genotypes[i] + "_" + maskGene + "_" + ages[k] + "_mask" + ".gif";
					masksHDFilenames[maskIndex] = imagesDirectory + "HD/masks/" + genotypes[i] + "_" + ages[k] + "_mask.png";
					maskIndex++;
				}

				index++;
			}
		}
	}
	console.log("Number of genotypes: " + genotypes.length);
	console.log("Number of genes: " + genes.length);
	console.log("Number of ages: " + ages.length);

	// loads image preview
	loader(imagesFilenames, images, loadImage, function () {

		// status
		var nullItems = 0;
		console.log("Preview images: " + images.length)
		for (var i = 0; i < images.length; i++) {
			if (images[i] == null && debug)
				console.log(imagesFilenames[i] + " is null.");
		}

		// paints viewer
		updateWingViewer();
	});

	// loads masks
	loader(masksFilenames, masks, loadImage, function () {

		// status
		var nullItems = 0;
		console.log("Preview masks: " + masks.length)
		for (var i = 0; i < masks.length; i++) {
			if (masks[i] == null && debug)
				console.log(masksFilenames[i] + " is null.");
		}

		// paints viewer
		updateWingViewer();

		// removes the tags placed while loading the images
		// document.getElementById("waitMessage").setAttribute("style", "visibility: hidden");
		removeElement("waitMessage");
	});

	// loads HD images
	loader(imagesHDFilenames, imagesHD, loadImage, function () {

		// status
		var nullItems = 0;
		console.log("HD images: " + imagesHD.length)
		for (var i = 0; i < imagesHD.length; i++) {
			if (imagesHD[i] == null && debug)
				console.log(imagesHDFilenames[i] + " is null.");
		}

		// paints viewer
		updateWingViewer();
	});

	// loads HD masks
	loader(masksHDFilenames, masksHD, loadImage, function () {

		// status
		var nullItems = 0;
		console.log("HD masks: " + masksHD.length)
		for (var i = 0; i < masksHD.length; i++) {
			if (masksHD[i] == null && debug)
				console.log(masksHDFilenames[i] + " is null.");
		}

		// paints viewer
		updateWingViewer();
	});
};

// ----------------------------------------------------------------------------

/** Returns the indexes of the selected images from the content of the form. */
function getSelectedImageIndexes() {

	var genotypeIndex = getSelectedGenotype();
	var geneIndexes = getSelectedGenes();
	var ageIndex = getSelectedAge();

	// get the indexes of the images to display
	var selectedImagesIndexes = new Array();
	for (var i = 0; i < 3; i++)
		selectedImagesIndexes[i] = genotypeIndex*(genes.length*ages.length) + geneIndexes[i]*ages.length + ageIndex;

	return selectedImagesIndexes;
}

// ----------------------------------------------------------------------------

/** Returns the index of the selected genotype from the content of the form. */
function getSelectedGenotype() {

	var genotypeIndex = 0;

	// gets selected genotype
	var genotypes = document.wviewerForm.genotypes;
	var n = genotypes.length;
	for (var i = 0; i < n; i++) {
		if (genotypes[i].checked) {
			genotypeIndex = i;
			break;
		}
	}
	return genotypeIndex;
}

// ----------------------------------------------------------------------------

/** Returns the indexes of the selected genes from the content of the form. */
function getSelectedGenes() {

	var geneIndexes = [0, 0, 0];

	// finds the indexes of the three selected genes
	var selectedGenes = new Array();
	selectedGenes[0] = document.wviewerForm.ch00.value;
	selectedGenes[1] = document.wviewerForm.ch01.value;
	selectedGenes[2] = document.wviewerForm.ch02.value;
	for (var i = 0; i < selectedGenes.length; i++) {
		for (var j = 0; j < genes.length; j++) {
			if (selectedGenes[i] == genes[j]) {
				geneIndexes[i] = j;
				break;
			}
		}
	}
	return geneIndexes;
}

// ----------------------------------------------------------------------------

/** Returns the index of the selected age from the content of the form. */
function getSelectedAge() {

	var ageIndex = 0;

	// gets selected age
	var ages = document.wviewerForm.ages;
	n = ages.length;
	for (var i = 0; i < n; i++) {
		if (ages[i].checked) {
			ageIndex = i;
			break;
		}
	}
	return ageIndex;
}

// ----------------------------------------------------------------------------

/** Returns the image of the selected mask. */
function getSelectedMaskIndex() {

	var genotypeIndex = getSelectedGenotype();
	var ageIndex = getSelectedAge();

	return (genotypeIndex*ages.length)+ ageIndex;
}

// ----------------------------------------------------------------------------

/** Returns a caption for the selected image. */
function getLightboxCaption() {

	var genotypeIndex = getSelectedGenotype();
	var geneIndexes = getSelectedGenes();
	var ageIndex = getSelectedAge();
	var colors = ["red", "green", "blue"];

	var caption = genotypesFormatted[genotypeIndex] + " Drosophila wing pouch (" + agesFormatted[ageIndex] + ")";
	var first = true;
	var noneCount = 0;
	for (var i = 0; i < geneIndexes.length; i++) {
		if (geneIndexes[i] != genesFormatted.length-1) {
			if (first) {
				caption += ": ";
				first = false;
			} else
				caption += ", ";
			caption += genesFormatted[geneIndexes[i]] + " (" + colors[i] + ")";
		} else
			noneCount++;
	}

	if (noneCount == geneIndexes.length)
		return "It's too dark to see anything.";

	return caption;
}

// ----------------------------------------------------------------------------

/** Updates the content of the viewer. */
function updateWingViewer() {

	// draws on the viewer canvas.
	drawRGBCanvas(canvas, images, masks);
	document.getElementById("panelImg").src = canvas.toDataURL();

	// draws canvas for lightbox
	// drawRGBCanvas(canvasHD, imagesHD, masksHD);
	var lightbox = document.getElementById("wviewerLightboxLink");
	// lightbox.href = canvasHD.toDataURL();
	lightbox.title = getLightboxCaption();
}

// ----------------------------------------------------------------------------

/**
 * Draws the preview of HD version of the viewer content.
 * First, a temporary canvas is created whose width is
 * four times the with of the target canvas/image.
 * The four parts of the tmp canvas are used to draw
 * the RGBA data. Three images are selected from myimages
 * depending on the selected genes, genotype, and age.
 * One image is then selected from mymasks depending on
 * the same variable. The mask is supposed to be in grayscale
 * and have transparency. If for a given pixel the mask is
 * opaque (mask[i+3]==255), the pixel value from the mask
 * (mask[i], mask[i+1] or mask[i+2], it's the same if the
 * image is in grayscale) is drawn. Otherwise the pixel value
 * comes from the select RGB images. If a gene is set to
 * "none", black pixel value (0) is used for the associated
 * channel.
 */
function drawRGBCanvas(mycanvas, myimages, mymasks) {

	// creates tmp canvas to draw the three channels before
	// manipulating the pixel values
	var tmpCanvas = document.createElement("canvas");
	// var tmpCanvas = document.getElementById('panel');
	tmpCanvas.width = 4*mycanvas.width; // the 4th is for the mask
	tmpCanvas.height = mycanvas.height;
	var tmpContext = tmpCanvas.getContext('2d');

	// gets the reference of the selected images and draws them
	// on the canvas at different location not visible
	var selectedImagesIndexes = getSelectedImageIndexes();
	var selectedImagesData = new Array();
	for (var i = 0; i < selectedImagesIndexes.length; i++) {
		var x = i*mycanvas.width;
		var y = 0;
		var img = myimages[selectedImagesIndexes[i]];
		if (img != null) {
			tmpContext.drawImage(img, x, y);
			selectedImagesData[i] = tmpContext.getImageData(x, y, mycanvas.width, mycanvas.height).data;
		} else {
			selectedImagesData[i] = null;
		}
	}

	// if the mask given is not null
	if (mymasks != null) {
		var x = 3*mycanvas.width;
		var y = 0;
		// all three channels must have the same mask
		var img = mymasks[getSelectedMaskIndex()];
		if (img != null) {
			tmpContext.drawImage(img, x, y);
			selectedImagesData[3] = tmpContext.getImageData(x, y, mycanvas.width, mycanvas.height).data;
		} else {
			selectedImagesData[3] = null;
		}
	}

	// console.log(selectedImagesData[3]);

	// // if there is only one channel different from null, paints in grayscale
	// var numNullChannel = 0;
	// var lastNonNullChannel = 0;
	// for (var i = 0; i < selectedImagesData.length; i++) {
		// if (selectedImagesData[i] != null)
			// lastNonNullChannel = i;
		// else
			// numNullChannel++;
	// }
	// var grayscaleChannel = -1;
	// if (numNullChannel == 2)
		// grayscaleChannel = lastNonNullChannel;


	// Gets the content of the context (its values are not used)
	// before changing it and repainting it.
	// Ideally, paint in grayscale if only one channel is selected.
	var mycontext = mycanvas.getContext('2d');
	var imgd = mycontext.getImageData(0, 0, mycanvas.width, mycanvas.height); // return ImageData
	var data = imgd.data; // Uint8ClampedArray (elements take values between 0 and 255)
    for (var i = 0, n = data.length; i < n; i += 4) {

		if (selectedImagesData[0] != null)
			data[i] = selectedImagesData[0][i]; // red
		else
			data[i] = 0;
		if (selectedImagesData[3] != null && selectedImagesData[3][i+3] == 255)
			data[i] = selectedImagesData[3][i];

		// else if (grayscaleChannel != -1)
			// data[i] = selectedImagesData[grayscaleChannel][i]; // if grayscale

		if (selectedImagesData[1] != null)
			data[i+1] = selectedImagesData[1][i+1]; // green
		else
			data[i+1] = 0;
		if (selectedImagesData[3] != null && selectedImagesData[3][i+3] == 255)
			data[i+1] = selectedImagesData[3][i];
		// else if (grayscaleChannel != -1)
			// data[i+1] = selectedImagesData[grayscaleChannel][i]; // if grayscale

		if (selectedImagesData[2] != null)
			data[i+2] = selectedImagesData[2][i+2]; // blue
		else
			data[i+2] = 0;
		if (selectedImagesData[3] != null && selectedImagesData[3][i+3] == 255) // && selectedImagesData[3][i] != 255
			data[i+2] = selectedImagesData[3][i];
		// else if (grayscaleChannel != -1)
			// data[i+2] = selectedImagesData[grayscaleChannel][i]; // if grayscale

		// if (selectedImagesData[3] != null && selectedImagesData[3][i+3] != 255)
			// data[i+3] = selectedImagesData[3][i]; // alpha proportional to the gray level
		// else
			// data[i+3] = 255; // visible


		// if (selectedImagesData[3] != null)
			// data[i+3] = selectedImagesData[3][i]; // alpha
		// else
			// data[i+3] = 255; // visible
    }

	// draws the image on the canvas
	mycontext.putImageData(imgd, 0, 0);
}

// ----------------------------------------------------------------------------

/** Computes the selected HD image and shows it. */
function computeAndShowHDImage() {

	// draws canvas for lightbox
	drawRGBCanvas(canvasHD, imagesHD, masksHD);
	var lightbox = document.getElementById("wviewerLightboxLink");
	lightbox.href = canvasHD.toDataURL();

	return true;
}

// ----------------------------------------------------------------------------

/** Removes the given HTML element. */
function removeElement(objID) {
    var node = document.getElementById(objID);
    node.parentNode.removeChild(node);
}